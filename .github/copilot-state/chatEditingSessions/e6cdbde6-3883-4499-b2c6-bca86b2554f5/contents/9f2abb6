// === Unique identifier types ===
export type CardId = string;
export type SummonInstanceId = string;

// === Card Types Enum ===
export type CardType =
  | "summon"
  | "action"
  | "reaction"
  | "counter"
  | "building"
  | "quest"
  | "advance"
  | "role"
  | "equipment";

// === Stat and Growth Rate Blocks ===
export interface StatBlock {
  STR: number;
  END: number;
  DEF: number;
  INT: number;
  SPI: number;
  MDF: number;
  SPD: number;
  ACC: number;
  LCK: number;
}

export interface GrowthRateBlock {
  STR: number;
  END: number;
  DEF: number;
  INT: number;
  SPI: number;
  MDF: number;
  SPD: number;
  ACC: number;
  LCK: number;
}

// === Rarity Types ===
export type Rarity = "common" | "uncommon" | "rare" | "legend" | "myth";

// === Stat Range for SummonTemplate ===
export interface StatRange {
  min: number;
  max: number;
}

// === Summon Template (Species definition, no rarity logic) ===
export interface SummonTemplate {
  id: string;
  name: string;
  description: string;
  species: string;
  card_type: "summon_template";
  attribute: string;
  base_stats: {
    STR: StatRange;
    END: StatRange;
    DEF: StatRange;
    INT: StatRange;
    SPI: StatRange;
    MDF: StatRange;
    SPD: StatRange;
    LCK: StatRange;
    ACC: StatRange;
  };
  // Optionally: possible_roles?: string[];
}

// === Growth Rate Probability Table (for Summon generation) ===
export type GrowthRateType = "Exceptional" | "Accelerated" | "Gradual" | "Normal" | "Steady" | "Minimal";

export type GrowthRateProbabilityTable = {
  [rarity in Rarity]: {
    [growthRate in GrowthRateType]: number;
  };
};

// Example usage:
// const growthRateProbabilities: GrowthRateProbabilityTable = { ... };

// === Rarity Growth Rate Table (optional, for mapping rarity to growth values) ===
export interface RarityGrowthRates {
  [rarity: string]: GrowthRateBlock;
}

// === Role/Equipment Data (flattened for SummonCard) ===
export interface RoleData {
  id: CardId;
  name: string;
  statModifiers: Partial<StatBlock>;
  // ...other role fields
}

export interface EquipmentData {
  id: CardId;
  name: string;
  slot: "weapon" | "offhand" | "armor" | "accessory";
  bonuses: Partial<StatBlock>;
  // ...other equipment fields
}

// === Base Card Interface ===
export interface CardBase {
  id: CardId;
  name: string;
  type: CardType;
  description: string;
  requirements?: Requirement[];
  triggers?: Trigger[];
  effects?: Effect[];
  // ...other shared fields (art, rarity, etc.)
}

// === SummonSlot (Deckbuilding only, not a Card) ===
export interface SummonSlot {
  summonId: CardId; // references a Summon template card
  roleId: CardId;   // references a Role card
  equipment: CardId[]; // up to 4, references Equipment cards
}

// === SummonCard (Playable, unique per game) ===
export interface SummonCard extends CardBase {
  type: "summon";
  summonInstanceId: SummonInstanceId; // unique per game
  baseStats: StatBlock;
  growthRates: GrowthRateBlock;
  species: string;
  rarity: string;
  role: RoleData;
  equipment: EquipmentData[];
  // ...other Summon-specific fields
}

// === Other Card Types (Atomic, not composite) ===
export interface ActionCard extends CardBase {
  type: "action";
  // ...action-specific fields
}
export interface ReactionCard extends CardBase {
  type: "reaction";
  // ...reaction-specific fields
}
export interface CounterCard extends CardBase {
  type: "counter";
  // ...counter-specific fields
}
export interface BuildingCard extends CardBase {
  type: "building";
  // ...building-specific fields
}
export interface QuestCard extends CardBase {
  type: "quest";
  // ...quest-specific fields
}
export interface AdvanceCard extends CardBase {
  type: "advance";
  // ...advance-specific fields
}

// === Role and Equipment (for deckbuilding, not playable) ===
export interface RoleCard extends CardBase {
  type: "role";
  statModifiers: Partial<StatBlock>;
  // ...role-specific fields
}
export interface EquipmentCard extends CardBase {
  type: "equipment";
  slot: "weapon" | "offhand" | "armor" | "accessory";
  bonuses: Partial<StatBlock>;
  // ...equipment-specific fields
}

// === Card Union ===
export type Card =
  | SummonCard
  | ActionCard
  | ReactionCard
  | CounterCard
  | BuildingCard
  | QuestCard
  | AdvanceCard
  | RoleCard
  | EquipmentCard;

// === Deck Structure ===
export interface Deck {
  summonSlots: SummonSlot[];
  mainDeck: CardId[];    // Action, Reaction, Counter, Building, Quest
  advanceDeck: CardId[]; // Advance cards
}

// === Requirements, Triggers, Effects (to be expanded later) ===

// === Requirement System ===
export type RequirementType =
  | "hasRoleInPlay"
  | "hasRoleOrAncestor"
  | "hasSummonInPlay"
  | "targetInRange"
  | "hasCardInHand"
  | "custom";

export interface Requirement<RT extends RequirementType = RequirementType> {
  type: RT;
  params?: RequirementParamsMap[RT];
  allOf?: Requirement[];
  anyOf?: Requirement[];
  not?: Requirement;
}

export type RequirementParamsMap = {
  hasRoleInPlay: { role: string; includeDescendants?: boolean };
  hasRoleOrAncestor: { role: string };
  hasSummonInPlay: { species?: string };
  targetInRange: { range: number };
  hasCardInHand: { cardId: CardId };
  custom: Record<string, unknown>;
};

// === Trigger System ===
export type TriggerType =
  | "onPlay"
  | "onPhaseStart"
  | "onSummonDefeated"
  | "onCardSet"
  | "onEffectResolved"
  | "custom";

export interface Trigger<TT extends TriggerType = TriggerType> {
  type: TT;
  params?: TriggerParamsMap[TT];
  requirements?: Requirement[];
}

export type TriggerParamsMap = {
  onPlay: Record<string, unknown>;
  onPhaseStart: { phase: string; turnsFromSet?: number; owner?: "self" | "opponent" };
  onSummonDefeated: { target?: TargetSelector };
  onCardSet: Record<string, unknown>;
  onEffectResolved: { effectType: EffectType };
  custom: Record<string, unknown>;
};

// === Effect System ===
export type EffectType =
  | "dealDamage"
  | "heal"
  | "drawCard"
  | "changeStat"
  | "moveUnit"
  | "destroy"
  | "setLevel"
  | "advanceSummon"
  | "modifyEquipmentStat"
  | "sequence"
  | "if"
  | "custom";

export interface Effect<ET extends EffectType = EffectType> {
  type: ET;
  params?: EffectParamsMap[ET];
  effects?: Effect[]; // for sequencing
  if?: {
    requirement: Requirement;
    then: Effect[];
    else?: Effect[];
  };
  target?: TargetSelector;
}

export type EffectParamsMap = {
  dealDamage: {
    amount?: number;
    formula?: string;
    formulaParams?: Record<string, unknown>;
    canCrit?: boolean;
    critFormula?: string;
    [key: string]: unknown;
  };
  heal: {
    amount?: number;
    formula?: string;
    formulaParams?: Record<string, unknown>;
    canCrit?: boolean;
    critFormula?: string;
    [key: string]: unknown;
  };
  drawCard: {
    amount?: number;
    formula?: string;
    formulaParams?: Record<string, unknown>;
    [key: string]: unknown;
  };
  changeStat: {
    stat: keyof StatBlock;
    amount?: number;
    formula?: string;
    formulaParams?: Record<string, unknown>;
    [key: string]: unknown;
  };
  moveUnit: {
    to?: { x: number; y: number };
    formula?: string;
    formulaParams?: Record<string, unknown>;
    [key: string]: unknown;
  };
  destroy: Record<string, unknown>;
  setLevel: {
    level?: number;
    formula?: string;
    formulaParams?: Record<string, unknown>;
    [key: string]: unknown;
  };
  advanceSummon: Record<string, unknown>;
  modifyEquipmentStat: {
    stat: string;
    amount?: number;
    formula?: string;
    formulaParams?: Record<string, unknown>;
    [key: string]: unknown;
  };
  sequence: Record<string, unknown>;
  if: Record<string, unknown>;
  custom: Record<string, unknown>;
};

// === Target Selector ===
export interface TargetSelector {
  type: string; // e.g. "self", "opponent", "summonInPlay", "allEnemies", etc.
  params?: Record<string, unknown>;
  requirements?: Requirement[];
}

// === Enhanced Game State & Context ===
export interface GameContext {
  currentPlayer: string;
  phase: GamePhase;
  turn: number;
  stack: StackEntry[];
  zones: GameZones;
  activeEffects: ActiveEffect[];
  triggerHistory: TriggerEvent[];
}

export type GamePhase = "draw" | "level" | "action" | "end";

export interface GameZones {
  [playerId: string]: PlayerZones;
  board: BoardState;
  inPlay: InPlayCard[];
}

export interface PlayerZones {
  hand: Card[];
  mainDeck: Card[];
  advanceDeck: Card[];
  discardPile: Card[];
  rechargePile: Card[];
}

export interface BoardState {
  grid: BoardCell[][];
  width: number;
  height: number;
}

export interface BoardCell {
  x: number;
  y: number;
  occupiedBy?: SummonInstanceId | string; // building id
  territory?: string; // player id or "neutral"
}

export interface InPlayCard {
  card: Card;
  controller: string;
  position?: { x: number; y: number };
  statusEffects: StatusEffect[];
  counters: Record<string, number>;
}

export interface StatusEffect {
  id: string;
  name: string;
  duration?: number; // turns remaining, undefined = permanent
  source: string; // card id that created this
  effects: Effect[];
}

// === Enhanced Stack System ===
export interface StackEntry {
  id: string;
  type: "trigger" | "response" | "resolution";
  source: string; // card id
  controller: string;
  speed: SpeedLevel;
  payload: TriggerEvent | ResponseAction | Resolution;
  timestamp: number;
}

export type SpeedLevel = "action" | "reaction" | "counter";

export interface TriggerEvent {
  id: string;
  type: TriggerType;
  source: string;
  context: Record<string, unknown>;
  participants: string[]; // entity ids involved
}

export interface ResponseAction {
  cardId: string;
  effectIndex?: number;
  targets: ResolvedTarget[];
  additionalContext?: Record<string, unknown>;
}

export interface Resolution {
  effectId: string;
  targets: ResolvedTarget[];
  calculations: CalculationResult[];
  outcomes: EffectOutcome[];
}

export interface ResolvedTarget {
  id: string;
  type: "summon" | "card" | "player" | "zone" | "position";
  zone?: string;
  position?: { x: number; y: number };
}

export interface CalculationResult {
  formula: string;
  inputs: Record<string, number>;
  result: number;
  rolled?: boolean; // if randomness was involved
}

export interface EffectOutcome {
  type: string;
  target: ResolvedTarget;
  value?: number;
  success: boolean;
  description: string;
}
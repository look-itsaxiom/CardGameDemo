{"version":2,"sessionId":"e6cdbde6-3883-4499-b2c6-bca86b2554f5","linearHistory":[{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","stops":[{"entries":[]},{"stopId":"6f6854df-9c1e-4b8b-8be6-ad6b7dad6832","entries":[{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts","languageId":"typescript","originalHash":"ec766d0","currentHash":"ec766d0","originalToCurrentEdit":[],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%226f6854df-9c1e-4b8b-8be6-ad6b7dad6832%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}}]},{"stopId":"eaa11aaa-5127-4fb5-b17f-f51ad5f8d5a7","entries":[{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts","languageId":"typescript","originalHash":"ec766d0","currentHash":"c48841a","originalToCurrentEdit":[{"txt":"\r\n// === Enhanced Game State & Context ===\r\nexport interface GameContext {\r\n  currentPlayer: string;\r\n  phase: GamePhase;\r\n  turn: number;\r\n  stack: StackEntry[];\r\n  zones: GameZones;\r\n  activeEffects: ActiveEffect[];\r\n  triggerHistory: TriggerEvent[];\r\n}\r\n\r\nexport type GamePhase = \"draw\" | \"level\" | \"action\" | \"end\";\r\n\r\nexport interface GameZones {\r\n  [playerId: string]: PlayerZones;\r\n  board: BoardState;\r\n  inPlay: InPlayCard[];\r\n}\r\n\r\nexport interface PlayerZones {\r\n  hand: Card[];\r\n  mainDeck: Card[];\r\n  advanceDeck: Card[];\r\n  discardPile: Card[];\r\n  rechargePile: Card[];\r\n}\r\n\r\nexport interface BoardState {\r\n  grid: BoardCell[][];\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface BoardCell {\r\n  x: number;\r\n  y: number;\r\n  occupiedBy?: SummonInstanceId | string; // building id\r\n  territory?: string; // player id or \"neutral\"\r\n}\r\n\r\nexport interface InPlayCard {\r\n  card: Card;\r\n  controller: string;\r\n  position?: { x: number; y: number };\r\n  statusEffects: StatusEffect[];\r\n  counters: Record<string, number>;\r\n}\r\n\r\nexport interface StatusEffect {\r\n  id: string;\r\n  name: string;\r\n  duration?: number; // turns remaining, undefined = permanent\r\n  source: string; // card id that created this\r\n  effects: Effect[];\r\n}\r\n\r\n// === Enhanced Stack System ===\r\nexport interface StackEntry {\r\n  id: string;\r\n  type: \"trigger\" | \"response\" | \"resolution\";\r\n  source: string; // card id\r\n  controller: string;\r\n  speed: SpeedLevel;\r\n  payload: TriggerEvent | ResponseAction | Resolution;\r\n  timestamp: number;\r\n}\r\n\r\nexport type SpeedLevel = \"action\" | \"reaction\" | \"counter\";\r\n\r\nexport interface TriggerEvent {\r\n  id: string;\r\n  type: TriggerType;\r\n  source: string;\r\n  context: Record<string, unknown>;\r\n  participants: string[]; // entity ids involved\r\n}\r\n\r\nexport interface ResponseAction {\r\n  cardId: string;\r\n  effectIndex?: number;\r\n  targets: ResolvedTarget[];\r\n  additionalContext?: Record<string, unknown>;\r\n}\r\n\r\nexport interface Resolution {\r\n  effectId: string;\r\n  targets: ResolvedTarget[];\r\n  calculations: CalculationResult[];\r\n  outcomes: EffectOutcome[];\r\n}\r\n\r\nexport interface ResolvedTarget {\r\n  id: string;\r\n  type: \"summon\" | \"card\" | \"player\" | \"zone\" | \"position\";\r\n  zone?: string;\r\n  position?: { x: number; y: number };\r\n}\r\n\r\nexport interface CalculationResult {\r\n  formula: string;\r\n  inputs: Record<string, number>;\r\n  result: number;\r\n  rolled?: boolean; // if randomness was involved\r\n}\r\n\r\nexport interface EffectOutcome {\r\n  type: string;\r\n  target: ResolvedTarget;\r\n  value?: number;\r\n  success: boolean;\r\n  description: string;\r\n}\r\n\r\n// === Enhanced Formula System ===\r\nexport interface Formula {\r\n  expression: string; // e.g., \"caster.STR * (1 + basePower/100) * (caster.STR / target.DEF)\"\r\n  variables: FormulaVariable[];\r\n  modifiers?: FormulaModifier[];\r\n}\r\n\r\nexport interface FormulaVariable {\r\n  name: string; // e.g., \"basePower\", \"caster.STR\"\r\n  source: VariableSource;\r\n  path?: string; // e.g., \"STR\" for stat access\r\n}\r\n\r\nexport type VariableSource = \"caster\" | \"target\" | \"self\" | \"params\" | \"context\" | \"constant\";\r\n\r\nexport interface FormulaModifier {\r\n  condition: Requirement;\r\n  operation: \"add\" | \"multiply\" | \"set\" | \"min\" | \"max\";\r\n  value: number | Formula;\r\n}\r\n\r\n// === Enhanced Targeting System ===\r\nexport interface TargetingRule {\r\n  selector: TargetSelector;\r\n  count: TargetCount;\r\n  optional?: boolean;\r\n  restrictions?: TargetRestriction[];\r\n}\r\n\r\nexport interface TargetCount {\r\n  min: number;\r\n  max: number;\r\n  formula?: Formula; // for dynamic targeting\r\n}\r\n\r\nexport interface TargetRestriction {\r\n  type: \"range\" | \"line-of-sight\" | \"same-zone\" | \"different-controller\";\r\n  params: Record<string, unknown>;\r\n}\r\n\r\nexport interface EnhancedTargetSelector extends TargetSelector {\r\n  filters: TargetFilter[];\r\n  priority?: TargetPriority;\r\n}\r\n\r\nexport interface TargetFilter {\r\n  type: \"entity-type\" | \"stat-range\" | \"has-status\" | \"controller\" | \"custom\";\r\n  params: Record<string, unknown>;\r\n  negate?: boolean;\r\n}\r\n\r\nexport interface TargetPriority {\r\n  criteria: string; // \"highest-hp\", \"lowest-hp\", \"nearest\", \"random\"\r\n  tiebreaker?: string;\r\n}\r\n\r\n// === Modular Effect System ===\r\nexport interface ModularEffect {\r\n  id: string;\r\n  type: EffectType;\r\n  timing: EffectTiming;\r\n  targeting: TargetingRule[];\r\n  execution: EffectExecution;\r\n  conditions?: EffectCondition[];\r\n  followUps?: FollowUpEffect[];\r\n}\r\n\r\nexport interface EffectTiming {\r\n  when: \"immediate\" | \"delayed\" | \"continuous\";\r\n  delay?: number; // turns\r\n  until?: Requirement; // condition for continuous effects to end\r\n}\r\n\r\nexport interface EffectExecution {\r\n  steps: ExecutionStep[];\r\n  rollback?: ExecutionStep[]; // for failed effects\r\n}\r\n\r\nexport interface ExecutionStep {\r\n  action: string; // \"calculate\", \"apply\", \"move\", \"create\", \"destroy\"\r\n  params: Record<string, unknown>;\r\n  formula?: Formula;\r\n  requirements?: Requirement[];\r\n}\r\n\r\nexport interface EffectCondition {\r\n  requirement: Requirement;\r\n  onFail: \"skip\" | \"abort\" | \"alternative\";\r\n  alternative?: ExecutionStep[];\r\n}\r\n\r\nexport interface FollowUpEffect {\r\n  trigger: TriggerType;\r\n  effect: ModularEffect;\r\n  once?: boolean;\r\n}\r\n\r\n// === Enhanced Trigger System ===\r\nexport interface EnhancedTrigger extends Trigger {\r\n  id: string;\r\n  priority: number; // for simultaneous triggers\r\n  conditions: TriggerCondition[];\r\n  response: TriggerResponse;\r\n}\r\n\r\nexport interface TriggerCondition {\r\n  requirement: Requirement;\r\n  context?: string[]; // what context variables are needed\r\n}\r\n\r\nexport interface TriggerResponse {\r\n  type: \"automatic\" | \"optional\" | \"choice\";\r\n  effects: ModularEffect[];\r\n  choices?: TriggerChoice[];\r\n}\r\n\r\nexport interface TriggerChoice {\r\n  id: string;\r\n  description: string;\r\n  effects: ModularEffect[];\r\n  requirements?: Requirement[];\r\n}\r\n\r\n// === Comprehensive Card Schema ===\r\nexport interface EnhancedCardBase extends CardBase {\r\n  metadata: CardMetadata;\r\n  gameRules: GameRules;\r\n  presentation: PresentationData;\r\n}\r\n\r\nexport interface CardMetadata {\r\n  set: string;\r\n  rarity: Rarity;\r\n  attribute?: string;\r\n  tags: string[];\r\n  version: string;\r\n}\r\n\r\nexport interface GameRules {\r\n  playRestrictions: PlayRestriction[];\r\n  triggers: EnhancedTrigger[];\r\n  effects: ModularEffect[];\r\n  staticAbilities?: StaticAbility[];\r\n}\r\n\r\nexport interface PlayRestriction {\r\n  phase: GamePhase[];\r\n  requirements: Requirement[];\r\n  costs?: Cost[];\r\n  timing?: \"sorcery\" | \"instant\"; // speed restrictions\r\n}\r\n\r\nexport interface Cost {\r\n  type: \"discard\" | \"sacrifice\" | \"stat-reduction\" | \"custom\";\r\n  amount?: number;\r\n  target?: TargetingRule;\r\n  optional?: boolean;\r\n}\r\n\r\nexport interface StaticAbility {\r\n  id: string;\r\n  description: string;\r\n  scope: \"self\" | \"controller\" | \"all\" | \"zone\";\r\n  effects: ModularEffect[];\r\n  conditions?: Requirement[];\r\n}\r\n\r\nexport interface PresentationData {\r\n  displayName: string;\r\n  flavorText?: string;\r\n  artAssets: ArtAsset[];\r\n  uiHints: UIHint[];\r\n}\r\n\r\nexport interface ArtAsset {\r\n  type: \"image\" | \"animation\" | \"sound\";\r\n  url: string;\r\n  tags: string[];\r\n}\r\n\r\nexport interface UIHint {\r\n  type: \"highlight\" | \"glow\" | \"particle\" | \"text\";\r\n  trigger: string;\r\n  params: Record<string, unknown>;\r\n}\r\n\r\n// === Active Game State Tracking ===\r\nexport interface ActiveEffect {\r\n  id: string;\r\n  source: string; // card that created it\r\n  effect: ModularEffect;\r\n  startTurn: number;\r\n  endCondition?: Requirement;\r\n  targets: ResolvedTarget[];\r\n  accumulator?: Record<string, unknown>; // for effects that build up\r\n}\r\n\r\n// === Enhanced Requirement System with Context ===\r\nexport interface ContextualRequirement extends Requirement {\r\n  contextKey?: string; // for referencing trigger context\r\n  validation: ValidationRule[];\r\n}\r\n\r\nexport interface ValidationRule {\r\n  check: string; // \"exists\", \"count\", \"stat-value\", \"custom\"\r\n  params: Record<string, unknown>;\r\n  errorMessage?: string;\r\n}\r\n\r\n// ...existing code...\r\n","pos":8275,"len":0}],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%22eaa11aaa-5127-4fb5-b17f-f51ad5f8d5a7%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}},{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%22eaa11aaa-5127-4fb5-b17f-f51ad5f8d5a7%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}}]},{"stopId":"4d6afe9e-2a3d-4fc6-8942-ced8939f0d70","entries":[{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"3f90681","originalToCurrentEdit":[{"txt":"import { \r\n  EnhancedCardBase, \r\n  ModularEffect, \r\n  EnhancedTrigger, \r\n  Formula,\r\n  TargetingRule,\r\n  PlayRestriction \r\n} from '../types';\r\n\r\n// Example: Blast Bolt - A simple damage spell\r\nexport const blastBoltExample: EnhancedCardBase = {\r\n  id: \"001-blast_bolt-Alpha\",\r\n  name: \"Blast Bolt\",\r\n  type: \"action\",\r\n  description: \"A long range bolt of fire that explodes on impact, dealing significant single-target damage.\",\r\n  \r\n  metadata: {\r\n    set: \"Alpha\",\r\n    rarity: \"rare\",\r\n    attribute: \"fire\",\r\n    tags: [\"spell\", \"damage\", \"ranged\"],\r\n    version: \"1.0\"\r\n  },\r\n\r\n  gameRules: {\r\n    playRestrictions: [\r\n      {\r\n        phase: [\"action\"],\r\n        requirements: [\r\n          {\r\n            type: \"hasRoleInPlay\",\r\n            params: { role: \"magician\", includeDescendants: true }\r\n          }\r\n        ],\r\n        timing: \"sorcery\"\r\n      }\r\n    ],\r\n\r\n    triggers: [\r\n      {\r\n        id: \"blast_bolt_on_play\",\r\n        type: \"onPlay\",\r\n        priority: 0,\r\n        conditions: [\r\n          {\r\n            requirement: {\r\n              type: \"hasRoleInPlay\",\r\n              params: { role: \"magician\" }\r\n            }\r\n          }\r\n        ],\r\n        response: {\r\n          type: \"automatic\",\r\n          effects: [\r\n            {\r\n              id: \"blast_bolt_damage\",\r\n              type: \"dealDamage\",\r\n              timing: { when: \"immediate\" },\r\n              targeting: [\r\n                {\r\n                  selector: {\r\n                    type: \"enemySummon\",\r\n                    params: { zone: \"inPlay\" }\r\n                  },\r\n                  count: { min: 1, max: 1 },\r\n                  restrictions: [\r\n                    {\r\n                      type: \"range\",\r\n                      params: { \r\n                        from: \"caster\", \r\n                        maxDistance: 6 \r\n                      }\r\n                    }\r\n                  ]\r\n                }\r\n              ],\r\n              execution: {\r\n                steps: [\r\n                  {\r\n                    action: \"calculate\",\r\n                    params: { resultKey: \"hitChance\" },\r\n                    formula: {\r\n                      expression: \"baseAccuracy + (caster.ACC / 10)\",\r\n                      variables: [\r\n                        { name: \"baseAccuracy\", source: \"constant\" },\r\n                        { name: \"caster.ACC\", source: \"caster\", path: \"ACC\" }\r\n                      ]\r\n                    }\r\n                  },\r\n                  {\r\n                    action: \"apply\",\r\n                    params: { \r\n                      type: \"hitRoll\",\r\n                      successThreshold: \"hitChance\"\r\n                    },\r\n                    requirements: [\r\n                      {\r\n                        type: \"custom\",\r\n                        params: { check: \"rollSuccess\" }\r\n                      }\r\n                    ]\r\n                  },\r\n                  {\r\n                    action: \"calculate\",\r\n                    params: { resultKey: \"damage\" },\r\n                    formula: {\r\n                      expression: \"caster.INT * (1 + basePower/100) * (caster.INT / target.MDF)\",\r\n                      variables: [\r\n                        { name: \"caster.INT\", source: \"caster\", path: \"INT\" },\r\n                        { name: \"basePower\", source: \"constant\" },\r\n                        { name: \"target.MDF\", source: \"target\", path: \"MDF\" }\r\n                      ]\r\n                    }\r\n                  },\r\n                  {\r\n                    action: \"apply\",\r\n                    params: { \r\n                      type: \"damage\",\r\n                      amount: \"damage\",\r\n                      damageType: \"magical\",\r\n                      attribute: \"fire\"\r\n                    }\r\n                  }\r\n                ]\r\n              },\r\n              conditions: [\r\n                {\r\n                  requirement: {\r\n                    type: \"targetInRange\",\r\n                    params: { range: 6 }\r\n                  },\r\n                  onFail: \"abort\"\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    ],\r\n\r\n    effects: [] // All effects are in triggers for this card\r\n  },\r\n\r\n  presentation: {\r\n    displayName: \"Blast Bolt\",\r\n    flavorText: \"Fire and fury, concentrated.\",\r\n    artAssets: [\r\n      {\r\n        type: \"image\",\r\n        url: \"/assets/cards/blast_bolt.png\",\r\n        tags: [\"card-art\"]\r\n      }\r\n    ],\r\n    uiHints: [\r\n      {\r\n        type: \"highlight\",\r\n        trigger: \"onTargetValid\",\r\n        params: { color: \"red\", intensity: 0.8 }\r\n      }\r\n    ]\r\n  }\r\n};\r\n\r\n// Example: Dark Altar - Complex building with delayed effect\r\nexport const darkAltarExample: EnhancedCardBase = {\r\n  id: \"010-dark_altar-Alpha\",\r\n  name: \"Dark Altar\",\r\n  type: \"building\",\r\n  description: \"At the end of your next turn, this building and any Summons within its spaces are destroyed. If a Summon was destroyed this way, target magician-based Summon you control becomes level 20 and you can immediately Advance using that Summon as a target.\",\r\n\r\n  metadata: {\r\n    set: \"Alpha\",\r\n    rarity: \"legend\",\r\n    attribute: \"dark\",\r\n    tags: [\"building\", \"destruction\", \"advancement\"],\r\n    version: \"1.0\"\r\n  },\r\n\r\n  gameRules: {\r\n    playRestrictions: [\r\n      {\r\n        phase: [\"action\"],\r\n        requirements: [\r\n          {\r\n            type: \"custom\",\r\n            params: { check: \"validBuildingPlacement\", width: 2, height: 2 }\r\n          }\r\n        ],\r\n        timing: \"sorcery\"\r\n      }\r\n    ],\r\n\r\n    triggers: [\r\n      {\r\n        id: \"dark_altar_delayed_destruction\",\r\n        type: \"onPhaseStart\",\r\n        params: { \r\n          phase: \"end\", \r\n          turnsFromSet: 1, \r\n          owner: \"self\" \r\n        },\r\n        priority: 10, // High priority for destruction effects\r\n        conditions: [\r\n          {\r\n            requirement: {\r\n              type: \"custom\",\r\n              params: { check: \"cardInPlay\", cardId: \"self\" }\r\n            }\r\n          }\r\n        ],\r\n        response: {\r\n          type: \"automatic\",\r\n          effects: [\r\n            {\r\n              id: \"destroy_altar_and_occupants\",\r\n              type: \"sequence\",\r\n              timing: { when: \"immediate\" },\r\n              targeting: [\r\n                {\r\n                  selector: {\r\n                    type: \"self\",\r\n                    params: {}\r\n                  },\r\n                  count: { min: 1, max: 1 }\r\n                },\r\n                {\r\n                  selector: {\r\n                    type: \"summonsInArea\",\r\n                    params: { area: \"selfOccupiedSpaces\" }\r\n                  },\r\n                  count: { min: 0, max: 99 }\r\n                }\r\n              ],\r\n              execution: {\r\n                steps: [\r\n                  {\r\n                    action: \"destroy\",\r\n                    params: { target: \"self\" }\r\n                  },\r\n                  {\r\n                    action: \"destroy\",\r\n                    params: { target: \"occupants\" }\r\n                  },\r\n                  {\r\n                    action: \"create\",\r\n                    params: { \r\n                      type: \"trigger\",\r\n                      triggerType: \"onSummonDefeated\",\r\n                      context: { source: \"dark_altar_destruction\" }\r\n                    }\r\n                  }\r\n                ]\r\n              },\r\n              followUps: [\r\n                {\r\n                  trigger: \"onSummonDefeated\",\r\n                  once: true,\r\n                  effect: {\r\n                    id: \"altar_advancement_bonus\",\r\n                    type: \"sequence\",\r\n                    timing: { when: \"immediate\" },\r\n                    targeting: [\r\n                      {\r\n                        selector: {\r\n                          type: \"controllerSummon\",\r\n                          params: { \r\n                            zone: \"inPlay\",\r\n                            roleFilter: \"magician\"\r\n                          }\r\n                        },\r\n                        count: { min: 1, max: 1 }\r\n                      }\r\n                    ],\r\n                    execution: {\r\n                      steps: [\r\n                        {\r\n                          action: \"apply\",\r\n                          params: { \r\n                            type: \"setLevel\",\r\n                            level: 20\r\n                          }\r\n                        },\r\n                        {\r\n                          action: \"create\",\r\n                          params: { \r\n                            type: \"permission\",\r\n                            permission: \"immediateAdvance\",\r\n                            target: \"selectedSummon\"\r\n                          }\r\n                        }\r\n                      ]\r\n                    }\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    ],\r\n\r\n    effects: [],\r\n\r\n    staticAbilities: [\r\n      {\r\n        id: \"altar_aura\",\r\n        description: \"Summons within the altar's spaces gain +2 INT but lose -1 SPI\",\r\n        scope: \"zone\",\r\n        effects: [\r\n          {\r\n            id: \"altar_stat_modification\",\r\n            type: \"changeStat\",\r\n            timing: { when: \"continuous\" },\r\n            targeting: [\r\n              {\r\n                selector: {\r\n                  type: \"summonsInArea\",\r\n                  params: { area: \"selfOccupiedSpaces\" }\r\n                },\r\n                count: { min: 0, max: 99 }\r\n              }\r\n            ],\r\n            execution: {\r\n              steps: [\r\n                {\r\n                  action: \"apply\",\r\n                  params: { \r\n                    type: \"statModifier\",\r\n                    stat: \"INT\",\r\n                    operation: \"add\",\r\n                    value: 2\r\n                  }\r\n                },\r\n                {\r\n                  action: \"apply\",\r\n                  params: { \r\n                    type: \"statModifier\",\r\n                    stat: \"SPI\",\r\n                    operation: \"add\",\r\n                    value: -1\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  },\r\n\r\n  presentation: {\r\n    displayName: \"Dark Altar\",\r\n    flavorText: \"Power demands sacrifice.\",\r\n    artAssets: [\r\n      {\r\n        type: \"image\",\r\n        url: \"/assets/cards/dark_altar.png\",\r\n        tags: [\"card-art\"]\r\n      },\r\n      {\r\n        type: \"animation\",\r\n        url: \"/assets/effects/dark_aura.json\",\r\n        tags: [\"building-effect\"]\r\n      }\r\n    ],\r\n    uiHints: [\r\n      {\r\n        type: \"glow\",\r\n        trigger: \"onPlacement\",\r\n        params: { color: \"purple\", duration: 3000 }\r\n      }\r\n    ]\r\n  }\r\n};\r\n\r\n// Example: Dramatic Return - Counter card with complex trigger\r\nexport const dramaticReturnExample: EnhancedCardBase = {\r\n  id: \"003-dramatic_return-Alpha\",\r\n  name: \"Dramatic Return!\",\r\n  type: \"counter\",\r\n  description: \"Trigger: A Summon you control is removed from In Play. Return that Summon to an unoccupied space within your territory with 10% HP.\",\r\n\r\n  metadata: {\r\n    set: \"Alpha\",\r\n    rarity: \"legend\",\r\n    attribute: \"light\",\r\n    tags: [\"counter\", \"resurrection\", \"protective\"],\r\n    version: \"1.0\"\r\n  },\r\n\r\n  gameRules: {\r\n    playRestrictions: [\r\n      {\r\n        phase: [\"action\"],\r\n        requirements: [],\r\n        timing: \"instant\"\r\n      }\r\n    ],\r\n\r\n    triggers: [\r\n      {\r\n        id: \"dramatic_return_set_trigger\",\r\n        type: \"onPlay\",\r\n        priority: 0,\r\n        conditions: [],\r\n        response: {\r\n          type: \"automatic\",\r\n          effects: [\r\n            {\r\n              id: \"set_counter_facedown\",\r\n              type: \"custom\",\r\n              timing: { when: \"immediate\" },\r\n              targeting: [],\r\n              execution: {\r\n                steps: [\r\n                  {\r\n                    action: \"apply\",\r\n                    params: { \r\n                      type: \"setCounterState\",\r\n                      state: \"facedown\",\r\n                      zone: \"inPlay\"\r\n                    }\r\n                  },\r\n                  {\r\n                    action: \"create\",\r\n                    params: { \r\n                      type: \"triggerListener\",\r\n                      listenFor: \"onSummonDefeated\",\r\n                      requirements: [\r\n                        {\r\n                          type: \"custom\",\r\n                          params: { \r\n                            check: \"summonController\",\r\n                            controller: \"self\"\r\n                          }\r\n                        }\r\n                      ]\r\n                    }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      {\r\n        id: \"dramatic_return_activation\",\r\n        type: \"onSummonDefeated\",\r\n        priority: 5, // Higher than normal to beat other responses\r\n        conditions: [\r\n          {\r\n            requirement: {\r\n              type: \"custom\",\r\n              params: { \r\n                check: \"triggerContext\",\r\n                contextKey: \"defeatedSummon.controller\",\r\n                equals: \"self\"\r\n              }\r\n            },\r\n            context: [\"defeatedSummon\"]\r\n          }\r\n        ],\r\n        response: {\r\n          type: \"optional\", // Player can choose to activate\r\n          effects: [\r\n            {\r\n              id: \"return_summon_to_play\",\r\n              type: \"custom\",\r\n              timing: { when: \"immediate\" },\r\n              targeting: [\r\n                {\r\n                  selector: {\r\n                    type: \"position\",\r\n                    params: { \r\n                      zone: \"controllerTerritory\",\r\n                      occupied: false\r\n                    }\r\n                  },\r\n                  count: { min: 1, max: 1 }\r\n                }\r\n              ],\r\n              execution: {\r\n                steps: [\r\n                  {\r\n                    action: \"calculate\",\r\n                    params: { resultKey: \"returnHP\" },\r\n                    formula: {\r\n                      expression: \"max(1, floor(maxHP * 0.1))\",\r\n                      variables: [\r\n                        { name: \"maxHP\", source: \"context\", path: \"defeatedSummon.maxHP\" }\r\n                      ]\r\n                    }\r\n                  },\r\n                  {\r\n                    action: \"create\",\r\n                    params: { \r\n                      type: \"summonUnit\",\r\n                      template: \"contextKey:defeatedSummon\",\r\n                      position: \"selectedPosition\",\r\n                      hp: \"returnHP\",\r\n                      skipSummonDraws: true\r\n                    }\r\n                  },\r\n                  {\r\n                    action: \"destroy\",\r\n                    params: { target: \"self\" }\r\n                  }\r\n                ]\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    ],\r\n\r\n    effects: []\r\n  },\r\n\r\n  presentation: {\r\n    displayName: \"Dramatic Return!\",\r\n    flavorText: \"Death is but a temporary setback.\",\r\n    artAssets: [\r\n      {\r\n        type: \"image\",\r\n        url: \"/assets/cards/dramatic_return.png\",\r\n        tags: [\"card-art\"]\r\n      }\r\n    ],\r\n    uiHints: [\r\n      {\r\n        type: \"text\",\r\n        trigger: \"onActivation\",\r\n        params: { text: \"DRAMATIC RETURN!\", color: \"gold\", size: \"large\" }\r\n      }\r\n    ]\r\n  }\r\n};\r\n","pos":0,"len":0}],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%224d6afe9e-2a3d-4fc6-8942-ced8939f0d70%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}},{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/SCHEMA_GUIDE.md","languageId":"markdown","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/SCHEMA_GUIDE.md?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%224d6afe9e-2a3d-4fc6-8942-ced8939f0d70%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}},{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%224d6afe9e-2a3d-4fc6-8942-ced8939f0d70%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}}]},{"stopId":"9d86c1a5-41eb-492b-ad4e-3fd1be11ec24","entries":[{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"85aea62","originalToCurrentEdit":[{"txt":"import { EnhancedCardBase } from '../../types/index';\r\n\r\n// Legacy card format interface (based on your existing data)\r\ninterface LegacyCard {\r\n  id: string;\r\n  name: string;\r\n  display_name: string;\r\n  description: string;\r\n  card_type: string;\r\n  target?: any;\r\n  caster?: any;\r\n  play_requirements?: any;\r\n  resolve_requirements?: any;\r\n  trigger?: string[];\r\n  resolve_timing?: string[];\r\n  effects?: any[];\r\n  attribute?: string;\r\n  rarity?: string;\r\n  zone_after_resolve?: string;\r\n}\r\n\r\n/**\r\n * Converts legacy card definitions to the new enhanced schema\r\n */\r\nexport class LegacyCardConverter {\r\n  \r\n  convert(legacyCard: LegacyCard): EnhancedCardBase {\r\n    return {\r\n      id: legacyCard.id,\r\n      name: legacyCard.display_name || legacyCard.name,\r\n      type: this.mapCardType(legacyCard.card_type),\r\n      description: legacyCard.description,\r\n      \r\n      metadata: {\r\n        set: this.extractSet(legacyCard.id),\r\n        rarity: (legacyCard.rarity as any) || \"common\",\r\n        attribute: legacyCard.attribute,\r\n        tags: this.generateTags(legacyCard),\r\n        version: \"1.0\"\r\n      },\r\n\r\n      gameRules: {\r\n        playRestrictions: this.convertPlayRestrictions(legacyCard),\r\n        triggers: this.convertTriggers(legacyCard),\r\n        effects: [], // Most effects are now in triggers\r\n        staticAbilities: []\r\n      },\r\n\r\n      presentation: {\r\n        displayName: legacyCard.display_name || legacyCard.name,\r\n        flavorText: undefined, // Not in legacy format\r\n        artAssets: [\r\n          {\r\n            type: \"image\",\r\n            url: `/assets/cards/${legacyCard.name}.png`,\r\n            tags: [\"card-art\"]\r\n          }\r\n        ],\r\n        uiHints: this.generateUIHints(legacyCard)\r\n      }\r\n    };\r\n  }\r\n\r\n  private mapCardType(legacyType: string): any {\r\n    const typeMap: Record<string, any> = {\r\n      'action': 'action',\r\n      'reaction': 'reaction', \r\n      'counter': 'counter',\r\n      'building': 'building',\r\n      'quest': 'quest',\r\n      'advance': 'advance',\r\n      'role': 'role',\r\n      'equipment': 'equipment',\r\n      'summon': 'summon'\r\n    };\r\n    return typeMap[legacyType] || 'action';\r\n  }\r\n\r\n  private extractSet(id: string): string {\r\n    // Extract set from ID format like \"001-blast_bolt-Alpha\"\r\n    const parts = id.split('-');\r\n    return parts[parts.length - 1] || \"Unknown\";\r\n  }\r\n\r\n  private generateTags(legacyCard: LegacyCard): string[] {\r\n    const tags: string[] = [];\r\n    \r\n    // Add type-based tags\r\n    tags.push(legacyCard.card_type);\r\n    \r\n    // Add attribute-based tags\r\n    if (legacyCard.attribute) {\r\n      tags.push(legacyCard.attribute);\r\n    }\r\n    \r\n    // Add effect-based tags\r\n    if (legacyCard.effects) {\r\n      for (const effect of legacyCard.effects) {\r\n        if (effect.type === 'damage') tags.push('damage');\r\n        if (effect.type === 'healing') tags.push('healing');\r\n        if (effect.type === 'summon_special') tags.push('summon');\r\n      }\r\n    }\r\n    \r\n    return tags;\r\n  }\r\n\r\n  private convertPlayRestrictions(legacyCard: LegacyCard): any[] {\r\n    const restrictions: any[] = [];\r\n    \r\n    // Convert play requirements to new format\r\n    if (legacyCard.play_requirements) {\r\n      const requirements: any[] = [];\r\n      \r\n      if (legacyCard.play_requirements.controlled_role) {\r\n        requirements.push({\r\n          type: \"hasRoleInPlay\",\r\n          params: { \r\n            role: legacyCard.play_requirements.controlled_role,\r\n            includeDescendants: true \r\n          }\r\n        });\r\n      }\r\n      \r\n      if (legacyCard.play_requirements.caster_valid && legacyCard.caster) {\r\n        requirements.push({\r\n          type: \"hasRoleInPlay\",\r\n          params: { \r\n            role: legacyCard.caster.role_type,\r\n            includeDescendants: true \r\n          }\r\n        });\r\n      }\r\n      \r\n      restrictions.push({\r\n        phase: [\"action\"], // Most legacy cards were action phase\r\n        requirements,\r\n        timing: legacyCard.card_type === 'counter' ? \"instant\" : \"sorcery\"\r\n      });\r\n    }\r\n    \r\n    return restrictions;\r\n  }\r\n\r\n  private convertTriggers(legacyCard: LegacyCard): any[] {\r\n    const triggers: any[] = [];\r\n    \r\n    if (legacyCard.trigger && legacyCard.effects) {\r\n      for (const triggerType of legacyCard.trigger) {\r\n        triggers.push({\r\n          id: `${legacyCard.name}_${triggerType}`,\r\n          type: this.mapTriggerType(triggerType),\r\n          priority: 0,\r\n          conditions: this.convertTriggerConditions(legacyCard),\r\n          response: {\r\n            type: legacyCard.card_type === 'counter' ? \"optional\" : \"automatic\",\r\n            effects: this.convertEffects(legacyCard)\r\n          }\r\n        });\r\n      }\r\n    }\r\n    \r\n    return triggers;\r\n  }\r\n\r\n  private mapTriggerType(legacyTrigger: string): string {\r\n    const triggerMap: Record<string, string> = {\r\n      'on_play': 'onPlay',\r\n      'on_summon_removed_controlled': 'onSummonDefeated',\r\n      'on_player_next_turn_end_phase': 'onPhaseStart',\r\n      'on_summon_damage_by_this_effect': 'onEffectResolved'\r\n    };\r\n    return triggerMap[legacyTrigger] || 'onPlay';\r\n  }\r\n\r\n  private convertTriggerConditions(legacyCard: LegacyCard): any[] {\r\n    const conditions: any[] = [];\r\n    \r\n    // Convert resolve requirements to trigger conditions\r\n    if (legacyCard.resolve_requirements) {\r\n      if (legacyCard.resolve_requirements.controlled_role) {\r\n        conditions.push({\r\n          requirement: {\r\n            type: \"hasRoleInPlay\",\r\n            params: { role: legacyCard.resolve_requirements.controlled_role }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    \r\n    return conditions;\r\n  }\r\n\r\n  private convertEffects(legacyCard: LegacyCard): any[] {\r\n    const effects: any[] = [];\r\n    \r\n    if (legacyCard.effects) {\r\n      for (const legacyEffect of legacyCard.effects) {\r\n        effects.push(this.convertSingleEffect(legacyEffect, legacyCard));\r\n      }\r\n    }\r\n    \r\n    return effects;\r\n  }\r\n\r\n  private convertSingleEffect(legacyEffect: any, card: LegacyCard): any {\r\n    const baseEffect = {\r\n      id: `${card.name}_${legacyEffect.type}`,\r\n      type: this.mapEffectType(legacyEffect.type),\r\n      timing: { when: \"immediate\" as const },\r\n      targeting: this.convertTargeting(card),\r\n      execution: {\r\n        steps: this.convertEffectSteps(legacyEffect)\r\n      }\r\n    };\r\n\r\n    return baseEffect;\r\n  }\r\n\r\n  private mapEffectType(legacyType: string): string {\r\n    const effectMap: Record<string, string> = {\r\n      'damage': 'dealDamage',\r\n      'healing': 'heal',\r\n      'change_target_zone_to_hand': 'drawCard',\r\n      'destroy_self': 'destroy',\r\n      'summon_special': 'custom'\r\n    };\r\n    return effectMap[legacyType] || 'custom';\r\n  }\r\n\r\n  private convertTargeting(card: LegacyCard): any[] {\r\n    const targeting: any[] = [];\r\n    \r\n    if (card.target) {\r\n      targeting.push({\r\n        selector: {\r\n          type: this.mapTargetType(card.target.type),\r\n          params: {\r\n            zone: card.target.zone || \"inPlay\",\r\n            controller: card.target.controller\r\n          }\r\n        },\r\n        count: {\r\n          min: card.target.amount || 1,\r\n          max: card.target.amount || 1\r\n        },\r\n        restrictions: card.target.range_from_caster ? [\r\n          {\r\n            type: \"range\",\r\n            params: { maxDistance: card.target.range_from_caster }\r\n          }\r\n        ] : []\r\n      });\r\n    }\r\n    \r\n    return targeting;\r\n  }\r\n\r\n  private mapTargetType(legacyType: string): string {\r\n    const targetMap: Record<string, string> = {\r\n      'summon': 'enemySummon',\r\n      'quest': 'questCard',\r\n      'any': 'anySummon'\r\n    };\r\n    return targetMap[legacyType] || 'enemySummon';\r\n  }\r\n\r\n  private convertEffectSteps(legacyEffect: any): any[] {\r\n    const steps: any[] = [];\r\n    \r\n    switch (legacyEffect.type) {\r\n      case 'damage':\r\n        if (legacyEffect.base_accuracy) {\r\n          steps.push({\r\n            action: \"calculate\",\r\n            params: { resultKey: \"hitChance\" },\r\n            formula: {\r\n              expression: legacyEffect.hit_formula === 'standard' \r\n                ? \"baseAccuracy + (caster.ACC / 10)\"\r\n                : legacyEffect.hit_formula,\r\n              variables: [\r\n                { name: \"baseAccuracy\", source: \"constant\" },\r\n                { name: \"caster.ACC\", source: \"caster\", path: \"ACC\" }\r\n              ]\r\n            }\r\n          });\r\n          \r\n          steps.push({\r\n            action: \"apply\",\r\n            params: { \r\n              type: \"hitRoll\",\r\n              successThreshold: \"hitChance\"\r\n            }\r\n          });\r\n        }\r\n        \r\n        if (legacyEffect.damage_formula) {\r\n          steps.push({\r\n            action: \"calculate\",\r\n            params: { resultKey: \"damage\" },\r\n            formula: {\r\n              expression: legacyEffect.damage_formula,\r\n              variables: this.extractFormulaVariables(legacyEffect.damage_formula)\r\n            }\r\n          });\r\n        }\r\n        \r\n        steps.push({\r\n          action: \"apply\",\r\n          params: {\r\n            type: \"damage\",\r\n            amount: \"damage\",\r\n            damageType: legacyEffect.damage_type,\r\n            attribute: legacyEffect.damage_attribute\r\n          }\r\n        });\r\n        break;\r\n        \r\n      case 'healing':\r\n        if (legacyEffect.healing_formula) {\r\n          steps.push({\r\n            action: \"calculate\", \r\n            params: { resultKey: \"healing\" },\r\n            formula: {\r\n              expression: legacyEffect.healing_formula,\r\n              variables: this.extractFormulaVariables(legacyEffect.healing_formula)\r\n            }\r\n          });\r\n        }\r\n        \r\n        steps.push({\r\n          action: \"apply\",\r\n          params: {\r\n            type: \"heal\",\r\n            amount: \"healing\",\r\n            healType: legacyEffect.healing_type,\r\n            attribute: legacyEffect.healing_attribute\r\n          }\r\n        });\r\n        break;\r\n        \r\n      default:\r\n        steps.push({\r\n          action: \"apply\",\r\n          params: { type: \"custom\", legacyEffect }\r\n        });\r\n    }\r\n    \r\n    return steps;\r\n  }\r\n\r\n  private extractFormulaVariables(formula: string): any[] {\r\n    const variables: any[] = [];\r\n    \r\n    // Simple regex to find variable patterns like \"caster.INT\", \"target.MDF\", etc.\r\n    const variableRegex = /(caster|target)\\.(\\w+)/g;\r\n    let match;\r\n    \r\n    while ((match = variableRegex.exec(formula)) !== null) {\r\n      const [fullMatch, source, stat] = match;\r\n      if (!variables.some(v => v.name === fullMatch)) {\r\n        variables.push({\r\n          name: fullMatch,\r\n          source: source as any,\r\n          path: stat\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Look for constants like \"base_power\", \"basePower\" \r\n    const constantRegex = /\\b(base_?power|base_?accuracy)\\b/g;\r\n    while ((match = constantRegex.exec(formula)) !== null) {\r\n      if (!variables.some(v => v.name === match[0])) {\r\n        variables.push({\r\n          name: match[0],\r\n          source: \"constant\" as any\r\n        });\r\n      }\r\n    }\r\n    \r\n    return variables;\r\n  }\r\n\r\n  private generateUIHints(legacyCard: LegacyCard): any[] {\r\n    const hints: any[] = [];\r\n    \r\n    // Add hints based on card type\r\n    if (legacyCard.card_type === 'action' && legacyCard.effects?.some(e => e.type === 'damage')) {\r\n      hints.push({\r\n        type: \"highlight\",\r\n        trigger: \"onTargetValid\", \r\n        params: { color: \"red\", intensity: 0.8 }\r\n      });\r\n    }\r\n    \r\n    if (legacyCard.card_type === 'counter') {\r\n      hints.push({\r\n        type: \"glow\",\r\n        trigger: \"onActivation\",\r\n        params: { color: \"blue\", duration: 2000 }\r\n      });\r\n    }\r\n    \r\n    return hints;\r\n  }\r\n}\r\n\r\n// Utility function to convert a batch of legacy cards\r\nexport function convertLegacyCards(legacyCards: LegacyCard[]): EnhancedCardBase[] {\r\n  const converter = new LegacyCardConverter();\r\n  return legacyCards.map(card => converter.convert(card));\r\n}\r\n\r\n// Example usage:\r\n// const legacyData = JSON.parse(fs.readFileSync('legacy-data/db.json', 'utf8'));\r\n// const enhancedCards = convertLegacyCards(legacyData.cards);\r\n","pos":0,"len":0}],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%229d86c1a5-41eb-492b-ad4e-3fd1be11ec24%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}}]}],"postEdit":[{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"970ee5a","originalToCurrentEdit":[{"txt":"import { EnhancedCardBase } from '../../types/index';\r\n\r\n// Legacy card format interface (based on your existing data)\r\ninterface LegacyCard {\r\n  id: string;\r\n  name: string;\r\n  display_name: string;\r\n  description: string;\r\n  card_type: string;\r\n  target?: any;\r\n  caster?: any;\r\n  play_requirements?: any;\r\n  resolve_requirements?: any;\r\n  trigger?: string[];\r\n  resolve_timing?: string[];\r\n  effects?: any[];\r\n  attribute?: string;\r\n  rarity?: string;\r\n  zone_after_resolve?: string;\r\n}\r\n\r\n/**\r\n * Converts legacy card definitions to the new enhanced schema\r\n */\r\nexport class LegacyCardConverter {\r\n  \r\n  convert(legacyCard: LegacyCard): EnhancedCardBase {\r\n    return {\r\n      id: legacyCard.id,\r\n      name: legacyCard.display_name || legacyCard.name,\r\n      type: this.mapCardType(legacyCard.card_type),\r\n      description: legacyCard.description,\r\n      \r\n      metadata: {\r\n        set: this.extractSet(legacyCard.id),\r\n        rarity: (legacyCard.rarity as any) || \"common\",\r\n        attribute: legacyCard.attribute,\r\n        tags: this.generateTags(legacyCard),\r\n        version: \"1.0\"\r\n      },\r\n\r\n      gameRules: {\r\n        playRestrictions: this.convertPlayRestrictions(legacyCard),\r\n        triggers: this.convertTriggers(legacyCard),\r\n        effects: [], // Most effects are now in triggers\r\n        staticAbilities: []\r\n      },\r\n\r\n      presentation: {\r\n        displayName: legacyCard.display_name || legacyCard.name,\r\n        flavorText: undefined, // Not in legacy format\r\n        artAssets: [\r\n          {\r\n            type: \"image\",\r\n            url: `/assets/cards/${legacyCard.name}.png`,\r\n            tags: [\"card-art\"]\r\n          }\r\n        ],\r\n        uiHints: this.generateUIHints(legacyCard)\r\n      }\r\n    };\r\n  }\r\n\r\n  private mapCardType(legacyType: string): any {\r\n    const typeMap: Record<string, any> = {\r\n      'action': 'action',\r\n      'reaction': 'reaction', \r\n      'counter': 'counter',\r\n      'building': 'building',\r\n      'quest': 'quest',\r\n      'advance': 'advance',\r\n      'role': 'role',\r\n      'equipment': 'equipment',\r\n      'summon': 'summon'\r\n    };\r\n    return typeMap[legacyType] || 'action';\r\n  }\r\n\r\n  private extractSet(id: string): string {\r\n    // Extract set from ID format like \"001-blast_bolt-Alpha\"\r\n    const parts = id.split('-');\r\n    return parts[parts.length - 1] || \"Unknown\";\r\n  }\r\n\r\n  private generateTags(legacyCard: LegacyCard): string[] {\r\n    const tags: string[] = [];\r\n    \r\n    // Add type-based tags\r\n    tags.push(legacyCard.card_type);\r\n    \r\n    // Add attribute-based tags\r\n    if (legacyCard.attribute) {\r\n      tags.push(legacyCard.attribute);\r\n    }\r\n    \r\n    // Add effect-based tags\r\n    if (legacyCard.effects) {\r\n      for (const effect of legacyCard.effects) {\r\n        if (effect.type === 'damage') tags.push('damage');\r\n        if (effect.type === 'healing') tags.push('healing');\r\n        if (effect.type === 'summon_special') tags.push('summon');\r\n      }\r\n    }\r\n    \r\n    return tags;\r\n  }\r\n\r\n  private convertPlayRestrictions(legacyCard: LegacyCard): any[] {\r\n    const restrictions: any[] = [];\r\n    \r\n    // Convert play requirements to new format\r\n    if (legacyCard.play_requirements) {\r\n      const requirements: any[] = [];\r\n      \r\n      if (legacyCard.play_requirements.controlled_role) {\r\n        requirements.push({\r\n          type: \"hasRoleInPlay\",\r\n          params: { \r\n            role: legacyCard.play_requirements.controlled_role,\r\n            includeDescendants: true \r\n          }\r\n        });\r\n      }\r\n      \r\n      if (legacyCard.play_requirements.caster_valid && legacyCard.caster) {\r\n        requirements.push({\r\n          type: \"hasRoleInPlay\",\r\n          params: { \r\n            role: legacyCard.caster.role_type,\r\n            includeDescendants: true \r\n          }\r\n        });\r\n      }\r\n      \r\n      restrictions.push({\r\n        phase: [\"action\"], // Most legacy cards were action phase\r\n        requirements,\r\n        timing: legacyCard.card_type === 'counter' ? \"instant\" : \"sorcery\"\r\n      });\r\n    }\r\n    \r\n    return restrictions;\r\n  }\r\n\r\n  private convertTriggers(legacyCard: LegacyCard): any[] {\r\n    const triggers: any[] = [];\r\n    \r\n    if (legacyCard.trigger && legacyCard.effects) {\r\n      for (const triggerType of legacyCard.trigger) {\r\n        triggers.push({\r\n          id: `${legacyCard.name}_${triggerType}`,\r\n          type: this.mapTriggerType(triggerType),\r\n          priority: 0,\r\n          conditions: this.convertTriggerConditions(legacyCard),\r\n          response: {\r\n            type: legacyCard.card_type === 'counter' ? \"optional\" : \"automatic\",\r\n            effects: this.convertEffects(legacyCard)\r\n          }\r\n        });\r\n      }\r\n    }\r\n    \r\n    return triggers;\r\n  }\r\n\r\n  private mapTriggerType(legacyTrigger: string): string {\r\n    const triggerMap: Record<string, string> = {\r\n      'on_play': 'onPlay',\r\n      'on_summon_removed_controlled': 'onSummonDefeated',\r\n      'on_player_next_turn_end_phase': 'onPhaseStart',\r\n      'on_summon_damage_by_this_effect': 'onEffectResolved'\r\n    };\r\n    return triggerMap[legacyTrigger] || 'onPlay';\r\n  }\r\n\r\n  private convertTriggerConditions(legacyCard: LegacyCard): any[] {\r\n    const conditions: any[] = [];\r\n    \r\n    // Convert resolve requirements to trigger conditions\r\n    if (legacyCard.resolve_requirements) {\r\n      if (legacyCard.resolve_requirements.controlled_role) {\r\n        conditions.push({\r\n          requirement: {\r\n            type: \"hasRoleInPlay\",\r\n            params: { role: legacyCard.resolve_requirements.controlled_role }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    \r\n    return conditions;\r\n  }\r\n\r\n  private convertEffects(legacyCard: LegacyCard): any[] {\r\n    const effects: any[] = [];\r\n    \r\n    if (legacyCard.effects) {\r\n      for (const legacyEffect of legacyCard.effects) {\r\n        effects.push(this.convertSingleEffect(legacyEffect, legacyCard));\r\n      }\r\n    }\r\n    \r\n    return effects;\r\n  }\r\n\r\n  private convertSingleEffect(legacyEffect: any, card: LegacyCard): any {\r\n    const baseEffect = {\r\n      id: `${card.name}_${legacyEffect.type}`,\r\n      type: this.mapEffectType(legacyEffect.type),\r\n      timing: { when: \"immediate\" as const },\r\n      targeting: this.convertTargeting(card),\r\n      execution: {\r\n        steps: this.convertEffectSteps(legacyEffect)\r\n      }\r\n    };\r\n\r\n    return baseEffect;\r\n  }\r\n\r\n  private mapEffectType(legacyType: string): string {\r\n    const effectMap: Record<string, string> = {\r\n      'damage': 'dealDamage',\r\n      'healing': 'heal',\r\n      'change_target_zone_to_hand': 'drawCard',\r\n      'destroy_self': 'destroy',\r\n      'summon_special': 'custom'\r\n    };\r\n    return effectMap[legacyType] || 'custom';\r\n  }\r\n\r\n  private convertTargeting(card: LegacyCard): any[] {\r\n    const targeting: any[] = [];\r\n    \r\n    if (card.target) {\r\n      targeting.push({\r\n        selector: {\r\n          type: this.mapTargetType(card.target.type),\r\n          params: {\r\n            zone: card.target.zone || \"inPlay\",\r\n            controller: card.target.controller\r\n          }\r\n        },\r\n        count: {\r\n          min: card.target.amount || 1,\r\n          max: card.target.amount || 1\r\n        },\r\n        restrictions: card.target.range_from_caster ? [\r\n          {\r\n            type: \"range\",\r\n            params: { maxDistance: card.target.range_from_caster }\r\n          }\r\n        ] : []\r\n      });\r\n    }\r\n    \r\n    return targeting;\r\n  }\r\n\r\n  private mapTargetType(legacyType: string): string {\r\n    const targetMap: Record<string, string> = {\r\n      'summon': 'enemySummon',\r\n      'quest': 'questCard',\r\n      'any': 'anySummon'\r\n    };\r\n    return targetMap[legacyType] || 'enemySummon';\r\n  }\r\n\r\n  private convertEffectSteps(legacyEffect: any): any[] {\r\n    const steps: any[] = [];\r\n    \r\n    switch (legacyEffect.type) {\r\n      case 'damage':\r\n        if (legacyEffect.base_accuracy) {\r\n          steps.push({\r\n            action: \"calculate\",\r\n            params: { resultKey: \"hitChance\" },\r\n            formula: {\r\n              expression: legacyEffect.hit_formula === 'standard' \r\n                ? \"baseAccuracy + (caster.ACC / 10)\"\r\n                : legacyEffect.hit_formula,\r\n              variables: [\r\n                { name: \"baseAccuracy\", source: \"constant\" },\r\n                { name: \"caster.ACC\", source: \"caster\", path: \"ACC\" }\r\n              ]\r\n            }\r\n          });\r\n          \r\n          steps.push({\r\n            action: \"apply\",\r\n            params: { \r\n              type: \"hitRoll\",\r\n              successThreshold: \"hitChance\"\r\n            }\r\n          });\r\n        }\r\n        \r\n        if (legacyEffect.damage_formula) {\r\n          steps.push({\r\n            action: \"calculate\",\r\n            params: { resultKey: \"damage\" },\r\n            formula: {\r\n              expression: legacyEffect.damage_formula,\r\n              variables: this.extractFormulaVariables(legacyEffect.damage_formula)\r\n            }\r\n          });\r\n        }\r\n        \r\n        steps.push({\r\n          action: \"apply\",\r\n          params: {\r\n            type: \"damage\",\r\n            amount: \"damage\",\r\n            damageType: legacyEffect.damage_type,\r\n            attribute: legacyEffect.damage_attribute\r\n          }\r\n        });\r\n        break;\r\n        \r\n      case 'healing':\r\n        if (legacyEffect.healing_formula) {\r\n          steps.push({\r\n            action: \"calculate\", \r\n            params: { resultKey: \"healing\" },\r\n            formula: {\r\n              expression: legacyEffect.healing_formula,\r\n              variables: this.extractFormulaVariables(legacyEffect.healing_formula)\r\n            }\r\n          });\r\n        }\r\n        \r\n        steps.push({\r\n          action: \"apply\",\r\n          params: {\r\n            type: \"heal\",\r\n            amount: \"healing\",\r\n            healType: legacyEffect.healing_type,\r\n            attribute: legacyEffect.healing_attribute\r\n          }\r\n        });\r\n        break;\r\n        \r\n      default:\r\n        steps.push({\r\n          action: \"apply\",\r\n          params: { type: \"custom\", legacyEffect }\r\n        });\r\n    }\r\n    \r\n    return steps;\r\n  }\r\n\r\n  private extractFormulaVariables(formula: string): any[] {\r\n    const variables: any[] = [];\r\n    \r\n    // Simple regex to find variable patterns like \"caster.INT\", \"target.MDF\", etc.\r\n    const variableRegex = /(caster|target)\\.(\\w+)/g;\r\n    let match: RegExpExecArray | null;\r\n    \r\n    while ((match = variableRegex.exec(formula)) !== null) {\r\n      const [fullMatch, source, stat] = match;\r\n      if (!variables.some(v => v.name === fullMatch)) {\r\n        variables.push({\r\n          name: fullMatch,\r\n          source: source as any,\r\n          path: stat\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Look for constants like \"base_power\", \"basePower\" \r\n    const constantRegex = /\\b(base_?power|base_?accuracy)\\b/g;\r\n    let constantMatch: RegExpExecArray | null;\r\n    while ((constantMatch = constantRegex.exec(formula)) !== null) {\r\n      if (!variables.some(v => v.name === constantMatch![0])) {\r\n        variables.push({\r\n          name: constantMatch[0],\r\n          source: \"constant\" as any\r\n        });\r\n      }\r\n    }\r\n    \r\n    return variables;\r\n  }\r\n\r\n  private generateUIHints(legacyCard: LegacyCard): any[] {\r\n    const hints: any[] = [];\r\n    \r\n    // Add hints based on card type\r\n    if (legacyCard.card_type === 'action' && legacyCard.effects?.some(e => e.type === 'damage')) {\r\n      hints.push({\r\n        type: \"highlight\",\r\n        trigger: \"onTargetValid\", \r\n        params: { color: \"red\", intensity: 0.8 }\r\n      });\r\n    }\r\n    \r\n    if (legacyCard.card_type === 'counter') {\r\n      hints.push({\r\n        type: \"glow\",\r\n        trigger: \"onActivation\",\r\n        params: { color: \"blue\", duration: 2000 }\r\n      });\r\n    }\r\n    \r\n    return hints;\r\n  }\r\n}\r\n\r\n// Utility function to convert a batch of legacy cards\r\nexport function convertLegacyCards(legacyCards: LegacyCard[]): EnhancedCardBase[] {\r\n  const converter = new LegacyCardConverter();\r\n  return legacyCards.map(card => converter.convert(card));\r\n}\r\n\r\n// Example usage:\r\n// const legacyData = JSON.parse(fs.readFileSync('legacy-data/db.json', 'utf8'));\r\n// const enhancedCards = convertLegacyCards(legacyData.cards);\r\n","pos":0,"len":0}],"state":0,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22request_1e9fe104-5f4e-4315-ad09-36269a770d86%22%2C%22undoStop%22%3A%22d19944f6-f46c-4e17-911b-79a8e843c7c0%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}}]}],"linearHistoryIndex":5,"initialFileContents":[["file:///c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts","ec766d0"],["file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts","da39a3e"],["file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/SCHEMA_GUIDE.md","da39a3e"],["file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts","da39a3e"]],"recentSnapshot":{"entries":[{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":2,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/types/index.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}},{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":2,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/examples/enhanced-card-examples.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}},{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/SCHEMA_GUIDE.md","languageId":"markdown","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":2,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/SCHEMA_GUIDE.md?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}},{"resource":"file:///c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts","languageId":"typescript","originalHash":"da39a3e","currentHash":"da39a3e","originalToCurrentEdit":[],"state":2,"snapshotUri":"chat-editing-snapshot-text-model:/c%3A/Users/cskib/Projects/CardGameDemo/src/data/converters/legacy-converter.ts?%7B%22sessionId%22%3A%22e6cdbde6-3883-4499-b2c6-bca86b2554f5%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_1e9fe104-5f4e-4315-ad09-36269a770d86","agentId":"github.copilot.editsAgent"}}]}}
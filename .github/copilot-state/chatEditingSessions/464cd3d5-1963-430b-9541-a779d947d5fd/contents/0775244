/**
 * Core calculation utilities for game mechanics
 * Implements the formulas described in the game design document
 */

import {
  Stats,
  StatType,
  GrowthRate,
  GROWTH_RATE_VALUES,
  StatCalculationConfig,
  StatCalculationResult,
  DerivedStatFormulas
} from '../types';

// ============================================================================
// STAT CALCULATION UTILITIES
// ============================================================================

/**
 * Calculate a single stat's value at a given level
 * Formula: FinalStat = (BaseStat + Floor(Level × GrowthRate) × Role Modifier) + Equipment Bonus + Other Bonuses
 */
export function calculateStat(config: StatCalculationConfig): StatCalculationResult {
  const { baseStat, growthRate, level, roleModifier, equipmentBonus, temporaryModifiers } = config;
  
  // Get numeric growth rate value
  const growthValue = GROWTH_RATE_VALUES[growthRate];
  
  // Calculate growth contribution
  const growthContribution = Math.floor(level * growthValue);
  
  // Apply role modifier to the base + growth
  const roleAdjusted = (baseStat + growthContribution) * roleModifier;
  
  // Add equipment and temporary bonuses
  const finalValue = roleAdjusted + equipmentBonus + temporaryModifiers;
  
  return {
    finalValue: Math.floor(finalValue), // Always round down
    breakdown: {
      base: baseStat,
      growth: growthContribution,
      role: roleAdjusted - (baseStat + growthContribution),
      equipment: equipmentBonus,
      temporary: temporaryModifiers
    }
  };
}

/**
 * Calculate all stats for a summon at a given level
 */
export function calculateAllStats(
  baseStats: Stats,
  growthRates: Record<StatType, GrowthRate>,
  level: number,
  roleModifiers: Partial<Stats> = {},
  equipmentBonuses: Partial<Stats> = {},
  temporaryModifiers: Partial<Stats> = {}
): Stats {
  const result: Partial<Stats> = {};
  
  for (const statType of Object.values(StatType)) {
    const config: StatCalculationConfig = {
      baseStat: baseStats[statType],
      growthRate: growthRates[statType],
      level,
      roleModifier: 1 + (roleModifiers[statType] || 0) / 100, // Convert to multiplier
      equipmentBonus: equipmentBonuses[statType] || 0,
      temporaryModifiers: temporaryModifiers[statType] || 0
    };
    
    result[statType] = calculateStat(config).finalValue;
  }
  
  return result as Stats;
}

// ============================================================================
// DERIVED STAT FORMULAS
// ============================================================================

/**
 * Implemented derived stat formulas from the game design
 */
export const DERIVED_STATS: DerivedStatFormulas = {
  /**
   * Max HP = 50 + Floor(END ^ 1.5)
   */
  maxHp: (endurance: number): number => {
    return 50 + Math.floor(Math.pow(endurance, 1.5));
  },

  /**
   * Movement Speed = 2 + Floor((SPD - 10) / 5)
   */
  movementSpeed: (speed: number): number => {
    return 2 + Math.floor((speed - 10) / 5);
  },

  /**
   * Basic Attack To Hit = 90 + (ACC / 10)
   */
  basicAttackToHit: (accuracy: number): number => {
    return 90 + (accuracy / 10);
  },

  /**
   * Critical Hit Chance = Floor((LCK × 0.3375) + 1.65)
   */
  criticalHitChance: (luck: number): number => {
    return Math.floor((luck * 0.3375) + 1.65);
  }
};

// ============================================================================
// DAMAGE CALCULATION UTILITIES
// ============================================================================

/**
 * Standard basic attack damage formula
 * STR × (1 + Weapon Power / 100) × (STR / Target DEF) × IF_CRIT
 */
export function calculateBasicAttackDamage(
  attackerStrength: number,
  weaponPower: number,
  targetDefense: number,
  isCritical: boolean = false,
  critMultiplier: number = 1.5
): number {
  const baseDamage = attackerStrength * (1 + weaponPower / 100) * (attackerStrength / targetDefense);
  const critAdjusted = isCritical ? baseDamage * critMultiplier : baseDamage;
  return Math.floor(critAdjusted);
}

/**
 * Enhanced basic attack damage for ranged weapons (bow formula)
 * ((STR + ACC) / 2) × (1 + Weapon Power / 100) × (STR / Target DEF) × IF_CRIT
 */
export function calculateRangedAttackDamage(
  attackerStrength: number,
  attackerAccuracy: number,
  weaponPower: number,
  targetDefense: number,
  isCritical: boolean = false,
  critMultiplier: number = 1.5
): number {
  const baseDamage = ((attackerStrength + attackerAccuracy) / 2) * 
                     (1 + weaponPower / 100) * 
                     (attackerStrength / targetDefense);
  const critAdjusted = isCritical ? baseDamage * critMultiplier : baseDamage;
  return Math.floor(critAdjusted);
}

/**
 * Magical attack damage formula
 * INT × (1 + Weapon Power / 100) × (INT / Target MDF) × IF_CRIT
 */
export function calculateMagicalAttackDamage(
  attackerIntelligence: number,
  weaponPower: number,
  targetMagicDefense: number,
  isCritical: boolean = false,
  critMultiplier: number = 1.5
): number {
  const baseDamage = attackerIntelligence * 
                     (1 + weaponPower / 100) * 
                     (attackerIntelligence / targetMagicDefense);
  const critAdjusted = isCritical ? baseDamage * critMultiplier : baseDamage;
  return Math.floor(critAdjusted);
}

/**
 * Standard healing formula
 * SPI × (1 + base_power / 100)
 */
export function calculateHealing(
  healerSpirit: number,
  basePower: number,
  isCritical: boolean = false,
  critMultiplier: number = 1.5
): number {
  const baseHealing = healerSpirit * (1 + basePower / 100);
  const critAdjusted = isCritical ? baseHealing * critMultiplier : baseHealing;
  return Math.floor(critAdjusted);
}

// ============================================================================
// PROBABILITY UTILITIES
// ============================================================================

/**
 * Generate a random number between min and max (inclusive)
 */
export function randomBetween(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Roll a percentage chance (0-100)
 * Returns true if the roll succeeds
 */
export function rollPercentage(chance: number): boolean {
  return Math.random() * 100 <= chance;
}

/**
 * Roll for critical hit
 */
export function rollCritical(luckStat: number): boolean {
  const critChance = DERIVED_STATS.criticalHitChance(luckStat);
  return rollPercentage(critChance);
}

/**
 * Roll for hit chance
 */
export function rollHit(accuracyStat: number, baseAccuracy: number = 90): boolean {
  const hitChance = DERIVED_STATS.basicAttackToHit(accuracyStat);
  const totalChance = Math.min(100, baseAccuracy + (accuracyStat / 10));
  return rollPercentage(totalChance);
}

// ============================================================================
// VALIDATION UTILITIES
// ============================================================================

/**
 * Validate that a level is within acceptable range (5-20)
 */
export function isValidLevel(level: number): boolean {
  return level >= 5 && level <= 20 && Number.isInteger(level);
}

/**
 * Validate that coordinates are within board bounds (0-11 x, 0-13 y)
 */
export function isValidCoordinate(x: number, y: number): boolean {
  return x >= 0 && x < 12 && y >= 0 && y < 14;
}

/**
 * Calculate distance between two coordinates
 */
export function calculateDistance(x1: number, y1: number, x2: number, y2: number): number {
  return Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1)); // Chess distance
}

/**
 * Check if a coordinate is within range of another
 */
export function isWithinRange(
  sourceX: number, 
  sourceY: number, 
  targetX: number, 
  targetY: number, 
  range: number
): boolean {
  return calculateDistance(sourceX, sourceY, targetX, targetY) <= range;
}

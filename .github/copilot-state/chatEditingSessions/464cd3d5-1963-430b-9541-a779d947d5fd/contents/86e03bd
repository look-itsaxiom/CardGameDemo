/**
 * Game state types for managing the active game session
 * This includes the board state, player state, and turn management
 */

import {
  Entity,
  EntityId,
  Player,
  TurnPhase,
  Zone,
  Coordinate,
  Stats,
  GrowthRates
} from './core';
import { Card, Deck, SummonSlot } from './cards';

// ============================================================================
// SUMMON UNIT (IN-PLAY SUMMON)
// ============================================================================

/** A summon unit that exists on the game board */
export interface SummonUnit extends Entity {
  /** Reference to the original summon card */
  originalCardId: EntityId;
  /** Current owner */
  playerId: EntityId;
  /** Current position on the board */
  position: Coordinate;
  /** Current level (5-20) */
  level: number;
  /** Current HP */
  currentHp: number;
  /** Maximum HP at current level */
  maxHp: number;
  /** Current calculated stats */
  currentStats: Stats;
  /** Base stats from the original card */
  baseStats: Stats;
  /** Growth rates from the original card */
  growthRates: GrowthRates;
  /** Currently equipped role */
  currentRole: EntityId;
  /** Currently equipped items */
  equipment: {
    weapon?: EntityId;
    offhand?: EntityId;
    armor?: EntityId;
    accessory?: EntityId;
  };
  /** Active status effects */
  statusEffects: StatusEffect[];
  /** Movement used this turn */
  movementUsed: number;
  /** Has attacked this turn */
  hasAttacked: boolean;
  /** Temporary modifiers from card effects */
  temporaryModifiers: TemporaryModifier[];
}

/** Status effects that can be applied to summon units */
export interface StatusEffect {
  id: string;
  name: string;
  description: string;
  /** How many turns remaining */
  duration: number;
  /** Stat modifiers */
  statModifiers?: Partial<Stats>;
  /** Special conditions */
  conditions?: {
    immobilized?: boolean;
    cannotAttack?: boolean;
    cannotUseAbilities?: boolean;
  };
  /** Source of this effect */
  sourceId: EntityId;
}

/** Temporary modifiers from card effects */
export interface TemporaryModifier {
  id: string;
  name: string;
  /** When this modifier expires */
  expiresAt: 'END_OF_TURN' | 'END_OF_OPPONENT_TURN' | 'PERMANENT' | number;
  /** Stat changes */
  statModifiers?: Partial<Stats>;
  /** Other property changes */
  propertyModifiers?: Record<string, any>;
  /** Source of this modifier */
  sourceId: EntityId;
}

// ============================================================================
// BOARD STATE
// ============================================================================

/** A space on the game board */
export interface BoardSpace {
  coordinate: Coordinate;
  /** Which player controls this territory (if any) */
  controlledBy?: EntityId;
  /** Summon unit occupying this space (if any) */
  occupiedBy?: EntityId;
  /** Buildings covering this space */
  buildings: EntityId[];
  /** Is this space valid for summon placement */
  isValidSummonSpace: boolean;
  /** Special terrain effects */
  terrainEffects?: string[];
}

/** The complete game board state */
export interface GameBoard {
  /** 12x14 grid of spaces */
  spaces: BoardSpace[][];
  /** Active summon units on the board */
  summonUnits: Map<EntityId, SummonUnit>;
  /** Active buildings on the board */
  buildings: Map<EntityId, ActiveBuilding>;
}

/** A building that has been played and is active on the board */
export interface ActiveBuilding extends Entity {
  /** Reference to the original building card */
  originalCardId: EntityId;
  /** Player who controls this building */
  playerId: EntityId;
  /** Spaces this building occupies */
  occupiedSpaces: Coordinate[];
  /** Is this building face down (hidden)? */
  isHidden: boolean;
  /** Turn when this building was played */
  playedOnTurn: number;
  /** Active timers for destruction */
  destructionTimers?: {
    type: 'TURN_COUNT' | 'CONDITION';
    value: number;
  }[];
}

// ============================================================================
// PLAYER GAME STATE
// ============================================================================

/** A player's state during an active game */
export interface PlayerGameState {
  player: Player;
  /** Cards in different zones */
  zones: {
    [Zone.HAND]: EntityId[];
    [Zone.MAIN_DECK]: EntityId[];
    [Zone.ADVANCE_DECK]: EntityId[];
    [Zone.DISCARD_PILE]: EntityId[];
    [Zone.RECHARGE_PILE]: EntityId[];
    [Zone.IN_PLAY]: EntityId[];
    [Zone.REMOVED]: EntityId[];
  };
  /** Original deck configuration */
  originalDeck: Deck;
  /** Summon slots as configured in deck */
  summonSlots: SummonSlot[];
  /** Which summon slots have been played this game */
  playedSummonSlots: boolean[];
  /** Has used turn summon this turn */
  hasUsedTurnSummon: boolean;
  /** Face-down cards in play (counters, reactions, etc.) */
  faceDownCards: Map<EntityId, Coordinate>;
}

// ============================================================================
// STACK SYSTEM
// ============================================================================

/** An action waiting to resolve on the stack */
export interface StackEntry {
  id: string;
  /** Player who initiated this action */
  playerId: EntityId;
  /** Type of action */
  actionType: 'PLAY_CARD' | 'ACTIVATE_ABILITY' | 'ATTACK' | 'MOVE' | 'TRIGGER_EFFECT';
  /** Source card or ability */
  sourceId: EntityId;
  /** Target(s) of this action */
  targets: ActionTarget[];
  /** Speed level of this action */
  speed: import('./core').Speed;
  /** Additional parameters */
  parameters: Record<string, any>;
  /** When this was added to the stack */
  timestamp: number;
}

/** Target for an action */
export interface ActionTarget {
  type: 'SUMMON_UNIT' | 'CARD' | 'PLAYER' | 'COORDINATE' | 'BUILDING';
  id?: EntityId;
  coordinate?: Coordinate;
  parameters?: Record<string, any>;
}

/** The game's action stack */
export interface ActionStack {
  entries: StackEntry[];
  /** Is the stack currently resolving */
  isResolving: boolean;
  /** Current priority holder */
  priorityPlayerId: EntityId;
}

// ============================================================================
// TURN MANAGEMENT
// ============================================================================

/** Turn state management */
export interface TurnState {
  /** Current turn number */
  turnNumber: number;
  /** Active player */
  activePlayerId: EntityId;
  /** Current phase */
  currentPhase: TurnPhase;
  /** Phase-specific data */
  phaseData?: Record<string, any>;
  /** Actions taken this turn */
  actionsTaken: StackEntry[];
}

// ============================================================================
// COMPLETE GAME STATE
// ============================================================================

/** The complete state of an active game */
export interface GameState {
  /** Unique game identifier */
  gameId: EntityId;
  /** Players in this game */
  players: Map<EntityId, PlayerGameState>;
  /** The game board */
  board: GameBoard;
  /** Action stack */
  stack: ActionStack;
  /** Turn management */
  turn: TurnState;
  /** All cards used in this game */
  gameCards: Map<EntityId, Card>;
  /** Game configuration */
  config: GameConfig;
  /** Game status */
  status: GameStatus;
  /** When the game started */
  startedAt: Date;
  /** Game history for replay */
  history: GameEvent[];
}

/** Game configuration settings */
export interface GameConfig {
  /** Game format (currently only 3v3 supported) */
  format: '3v3';
  /** Time limits */
  timeLimits?: {
    turnTimeLimit: number; // seconds
    gameTimeLimit: number; // seconds
  };
  /** Rule variations */
  rules: {
    allowSpectators: boolean;
    allowUndo: boolean;
    allowPause: boolean;
  };
}

/** Overall game status */
export interface GameStatus {
  state: 'WAITING' | 'IN_PROGRESS' | 'COMPLETED' | 'PAUSED' | 'ABANDONED';
  /** Winner if game is completed */
  winnerId?: EntityId;
  /** Reason for game end */
  endReason?: 'VICTORY_POINTS' | 'TIMEOUT' | 'FORFEIT' | 'DRAW';
  /** Current scores */
  scores: Map<EntityId, number>;
}

/** Events that occur during the game for history/replay */
export interface GameEvent {
  id: string;
  timestamp: Date;
  playerId: EntityId;
  eventType: 'CARD_PLAYED' | 'ATTACK' | 'MOVE' | 'ABILITY_ACTIVATED' | 
             'PHASE_CHANGE' | 'TURN_CHANGE' | 'GAME_END';
  details: Record<string, any>;
  /** Stack state when this event occurred */
  stackSnapshot?: StackEntry[];
}

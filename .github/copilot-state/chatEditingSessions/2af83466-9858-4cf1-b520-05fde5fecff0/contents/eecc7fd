# Project Master Plan: Tactical Card Game Demo

## Vision

Deliver a robust, extensible, and data-driven tactical RPG card game demo. The MVP is a self-contained, local snapshot of the larger product, focused on the core gameplay loop, data models, and extensibility. This demo will serve as the foundation for future expansion into a full-stack, multiplayer, authoritative-server product.

## MVP Goals

- All game data (cards, decks, board, etc.) is defined in TypeScript interfaces and/or static JSON, not hardcoded logic.
- The game engine is modular, with strict separation between game logic (engine/state) and UI (Phaser/React).
- The core gameplay loop (turns, phases, actions, triggers, stack, win/loss) is fully implemented and testable.
- The system is designed for easy extension: new cards, mechanics, or rules can be added by editing data, not code.
- UI is functional and clear, using React for menus/collection/deckbuilder and Phaser 3 for the board/gameplay.
- No backend, authentication, or real-time multiplayer—just local, stubbed data and single-session play.

## Core Design Pillars

1. **Data-Driven Game Logic**
   - All card effects, requirements, triggers, and rules are defined in structured data (JSON/TypeScript), not as bespoke scripts per card.
   - The engine interprets this data to drive all gameplay mechanics.

2. **Separation of Concerns**
   - Game logic (engine/state) is completely decoupled from UI (Phaser/React).
   - The UI is a “dumb” renderer and input collector, never the source of truth.

3. **Authoritative Server Mindset**
   - The architecture treats the game engine as the “server” and the UI as “clients” that submit actions and receive state updates.
   - This enables a future transition to a true backend authoritative server with minimal refactor.

## System Breakdown & Architecture Overview

### 1. Data Layer
- **Card Definitions:** All card types, effects, triggers, requirements, and stats defined in JSON or TypeScript interfaces.
- **Decks & Collections:** Player decks, collections, and stubbed user data.
- **Board & Zones:** Board layout, zones, and initial state.

### 2. Game Engine (Authoritative Logic)
- **State Management:** Holds the canonical game state (board, hands, decks, discard, etc.).
- **Action Interpreter:** Receives user actions (play card, move unit, attack, etc.), validates them, and applies state changes.
- **Effect/Trigger System:** Evaluates triggers, requirements, and resolves effects using data definitions.
- **Stack & Priority:** Manages the stack, responses, and resolution order.
- **Stat Calculation:** Computes unit stats, damage, healing, and other derived values from data.
- **Victory/End Conditions:** Checks for win/loss/draw and game over.

### 3. UI Layer
- **React UI:** Deck builder, card collection, menus, and game setup.
- **Phaser 3 Board:** Visualizes the board, units, and in-play actions.
- **UI-State Sync:** Subscribes to game state updates and renders accordingly. Sends user actions to the engine.

### 4. Extensibility & Testing
- **Data-Driven Expansion:** New cards, effects, and mechanics added via data, not code changes.
- **Unit & Integration Tests:** Test game logic, state transitions, and effect resolution.
- **Debug Tools:** UI for inspecting state, simulating actions, and visualizing the stack.

### 5. Future-Proofing
- **Server-Client Split:** Engine is designed to run headless (server-side) or in-browser (client-side) with the same API.
- **Networking Ready:** All user actions are serializable and replayable for multiplayer or server validation.

---

## Next: Top-Level Entity Map & Relationships
- **Goal:** Clearly define the main entities (GameState, Player, Card, Board, Action, etc.) and how they interact, so that every part of the game has a place in the data model.
- **Acceptance Criteria:**
  - All major game concepts from the play example are represented as entities or relationships.
  - Relationships between entities (e.g., Player owns Deck, Board contains Units) are explicit.
  - A diagram or table shows how everything fits together.

## Next: Card & Effect Schema Design
- **Goal:** Create TypeScript interfaces for all card types, effects, triggers, requirements, and actions, so that every mechanic in the play example can be described in data.
- **Acceptance Criteria:**
  - Every card in the play example can be represented as a data object.
  - Effects, triggers, and requirements are data-driven and extensible.
  - Adding a new card or mechanic is possible without engine code changes.
  - Example card data objects are included for reference.

## Next: Game Engine Core Loop
- **Goal:** Outline and implement the main phases and state transitions (Draw, Level, Action, End, etc.), and define how user actions are submitted, validated, and resolved by the engine.
- **Acceptance Criteria:**
  - The full turn cycle is implemented and matches the play example.
  - Actions (play card, move, attack, etc.) are submitted as data and processed by the engine.
  - The stack, triggers, and resolutions are handled according to the rules.
  - The engine can be run headless for testing.

## Next: UI & Client Integration
- **Goal:** Connect React and Phaser 3 to the engine, so that the UI reflects game state and user actions are sent to the engine, not handled directly in the UI.
- **Acceptance Criteria:**
  - UI updates in response to state changes from the engine.
  - All user actions (clicks, drags, selections) are sent as data to the engine.
  - No game logic is duplicated in the UI layer.
  - The UI can be swapped or updated without breaking the engine.

## Next: Testing & Debugging Tools
- **Goal:** Provide tools for testing and debugging the game logic, including unit/integration tests and a debug UI for inspecting state and simulating actions.
- **Acceptance Criteria:**
  - Core engine logic is covered by automated tests.
  - Developers can inspect the stack, triggers, and state transitions in real time.
  - Simulated actions and test scenarios can be run without the full UI.

## Next: Roadmap to Full Product
- **Goal:** Identify the steps needed to evolve the MVP into a full-stack, multiplayer, live product, including backend, networking, and live ops features.
- **Acceptance Criteria:**
  - A clear migration path from local MVP to server-authoritative multiplayer is documented.
  - Key backend features (auth, persistence, matchmaking, etc.) are listed.
  - The architecture supports future live updates and content drops.

---

*This document is a living master plan. Each section will be expanded and refined as the project evolves.*
